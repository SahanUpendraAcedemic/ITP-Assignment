import { semaphore } from "@node-libraries/semaphore";
import { SignJWT, importPKCS8 } from "jose";
export const createToken = ({ clientEmail, privateKey, }) => importPKCS8(privateKey, "RS256").then((key) => new SignJWT({
    iss: clientEmail,
    sub: clientEmail,
    scope: "https://www.googleapis.com/auth/cloud-platform",
    iat: Math.floor(Date.now() / 1000) - 30,
    exp: Math.floor(Date.now() / 1000) + 3600,
})
    .setProtectedHeader({ alg: "RS256", typ: "JWT" })
    .sign(key));
export const info = ({ token, bucket, name, }) => {
    const url = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o/${encodeURIComponent(name)}`;
    return fetch(url, {
        method: "GET",
        headers: {
            Authorization: `Bearer ${token}`,
        },
    }).then((res) => {
        if (res.status !== 200)
            throw new Error(res.statusText);
        return res.json();
    });
};
export const download = ({ token, bucket, name, }) => {
    const url = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o/${encodeURIComponent(name)}?alt=media&no=${Date.now()}`;
    return fetch(url, {
        method: "GET",
        headers: {
            Authorization: `Bearer ${token}`,
        },
    }).then((res) => {
        if (res.status !== 200)
            throw new Error(res.statusText);
        return res.arrayBuffer();
    });
};
export const upload = ({ token, bucket, name, file, published, metadata, }) => {
    const id = encodeURI(name);
    const url = `https://storage.googleapis.com/upload/storage/v1/b/${encodeURIComponent(bucket)}/o?name=${id}&uploadType=multipart${published ? "&predefinedAcl=publicRead" : ""}`;
    const body = new FormData();
    body.append("", new Blob([JSON.stringify({ metadata })], { type: "application/json" }));
    body.append("", file);
    return fetch(url, {
        method: "POST",
        headers: {
            Authorization: `Bearer ${token}`,
        },
        body: body,
    }).then((res) => {
        if (res.status !== 200)
            throw new Error(res.statusText);
        return res.json();
    });
};
export const del = ({ token, bucket, name, }) => {
    const url = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o/${encodeURIComponent(name)}`;
    return fetch(url, {
        method: "DELETE",
        headers: {
            Authorization: `Bearer ${token}`,
        },
    }).then((res) => {
        if (res.status !== 204)
            throw new Error(res.statusText);
        return true;
    });
};
export const list = ({ token, bucket, }) => {
    const url = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o`;
    return fetch(url, {
        headers: {
            Authorization: `Bearer ${token}`,
        },
    })
        .then((res) => {
        if (res.status !== 200)
            throw new Error(res.statusText);
        return res.json();
    })
        .then((res) => res.items);
};
export const infoBucket = ({ token, bucket, }) => {
    const url = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}`;
    return fetch(url, {
        headers: {
            Authorization: `Bearer ${token}`,
        },
    })
        .then((res) => {
        if (res.status !== 200)
            throw new Error(res.statusText);
        return res.json();
    })
        .then((res) => res);
};
export const updateBucket = ({ token, bucket, body, }) => {
    const url = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}`;
    return fetch(url, {
        method: "PATCH",
        headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(body),
    })
        .then((res) => {
        if (res.status !== 200)
            throw new Error(res.statusText);
        return res.json();
    })
        .then((res) => res);
};
export const getStorage = ({ clientEmail, privateKey, bucket: _bucket, parallels = 1000, }) => {
    const property = {
        token: "",
        expire: 0,
    };
    const getToken = async () => {
        if (property.expire > Date.now() / 1000 + 300)
            return property.token;
        property.expire = Math.floor(Date.now() / 1000) + 3600;
        property.token = await createToken({ clientEmail, privateKey });
        return property.token;
    };
    const getBucket = (bucket) => {
        const result = bucket ?? _bucket;
        if (!result)
            throw new Error("bucket is not defined");
        return result;
    };
    const s = semaphore(parallels);
    return {
        info: async (params) => {
            await s.acquire();
            return info({
                ...params,
                token: await getToken(),
                bucket: getBucket(params.bucket),
            }).finally(() => s.release());
        },
        download: async (params) => {
            await s.acquire();
            return download({
                ...params,
                token: await getToken(),
                bucket: getBucket(params.bucket),
            }).finally(() => s.release());
        },
        upload: async (params) => {
            await s.acquire();
            return upload({
                ...params,
                token: await getToken(),
                bucket: getBucket(params.bucket),
            }).finally(() => s.release());
        },
        del: async (params) => {
            await s.acquire();
            return del({
                ...params,
                token: await getToken(),
                bucket: getBucket(params.bucket),
            }).finally(() => s.release());
        },
        list: async (params) => {
            await s.acquire();
            return list({
                ...params,
                token: await getToken(),
                bucket: getBucket(params.bucket),
            }).finally(() => s.release());
        },
        infoBucket: async (params) => {
            await s.acquire();
            return infoBucket({
                ...params,
                token: await getToken(),
                bucket: getBucket(params.bucket),
            }).finally(() => s.release());
        },
        updateBucket: async (params) => {
            await s.acquire();
            return updateBucket({
                ...params,
                token: await getToken(),
                bucket: getBucket(params.bucket),
            }).finally(() => s.release());
        },
    };
};
