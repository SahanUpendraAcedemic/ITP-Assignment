"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStorage = exports.updateBucket = exports.infoBucket = exports.list = exports.del = exports.upload = exports.download = exports.info = exports.createToken = void 0;
const semaphore_1 = require("@node-libraries/semaphore");
const jose_1 = require("jose");
const createToken = ({ clientEmail, privateKey, }) => (0, jose_1.importPKCS8)(privateKey, "RS256").then((key) => new jose_1.SignJWT({
    iss: clientEmail,
    sub: clientEmail,
    scope: "https://www.googleapis.com/auth/cloud-platform",
    iat: Math.floor(Date.now() / 1000) - 30,
    exp: Math.floor(Date.now() / 1000) + 3600,
})
    .setProtectedHeader({ alg: "RS256", typ: "JWT" })
    .sign(key));
exports.createToken = createToken;
const info = ({ token, bucket, name, }) => {
    const url = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o/${encodeURIComponent(name)}`;
    return fetch(url, {
        method: "GET",
        headers: {
            Authorization: `Bearer ${token}`,
        },
    }).then((res) => {
        if (res.status !== 200)
            throw new Error(res.statusText);
        return res.json();
    });
};
exports.info = info;
const download = ({ token, bucket, name, }) => {
    const url = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o/${encodeURIComponent(name)}?alt=media&no=${Date.now()}`;
    return fetch(url, {
        method: "GET",
        headers: {
            Authorization: `Bearer ${token}`,
        },
    }).then((res) => {
        if (res.status !== 200)
            throw new Error(res.statusText);
        return res.arrayBuffer();
    });
};
exports.download = download;
const upload = ({ token, bucket, name, file, published, metadata, }) => {
    const id = encodeURI(name);
    const url = `https://storage.googleapis.com/upload/storage/v1/b/${encodeURIComponent(bucket)}/o?name=${id}&uploadType=multipart${published ? "&predefinedAcl=publicRead" : ""}`;
    const body = new FormData();
    body.append("", new Blob([JSON.stringify({ metadata })], { type: "application/json" }));
    body.append("", file);
    return fetch(url, {
        method: "POST",
        headers: {
            Authorization: `Bearer ${token}`,
        },
        body: body,
    }).then((res) => {
        if (res.status !== 200)
            throw new Error(res.statusText);
        return res.json();
    });
};
exports.upload = upload;
const del = ({ token, bucket, name, }) => {
    const url = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o/${encodeURIComponent(name)}`;
    return fetch(url, {
        method: "DELETE",
        headers: {
            Authorization: `Bearer ${token}`,
        },
    }).then((res) => {
        if (res.status !== 204)
            throw new Error(res.statusText);
        return true;
    });
};
exports.del = del;
const list = ({ token, bucket, }) => {
    const url = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o`;
    return fetch(url, {
        headers: {
            Authorization: `Bearer ${token}`,
        },
    })
        .then((res) => {
        if (res.status !== 200)
            throw new Error(res.statusText);
        return res.json();
    })
        .then((res) => res.items);
};
exports.list = list;
const infoBucket = ({ token, bucket, }) => {
    const url = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}`;
    return fetch(url, {
        headers: {
            Authorization: `Bearer ${token}`,
        },
    })
        .then((res) => {
        if (res.status !== 200)
            throw new Error(res.statusText);
        return res.json();
    })
        .then((res) => res);
};
exports.infoBucket = infoBucket;
const updateBucket = ({ token, bucket, body, }) => {
    const url = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}`;
    return fetch(url, {
        method: "PATCH",
        headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(body),
    })
        .then((res) => {
        if (res.status !== 200)
            throw new Error(res.statusText);
        return res.json();
    })
        .then((res) => res);
};
exports.updateBucket = updateBucket;
const getStorage = ({ clientEmail, privateKey, bucket: _bucket, parallels = 1000, }) => {
    const property = {
        token: "",
        expire: 0,
    };
    const getToken = async () => {
        if (property.expire > Date.now() / 1000 + 300)
            return property.token;
        property.expire = Math.floor(Date.now() / 1000) + 3600;
        property.token = await (0, exports.createToken)({ clientEmail, privateKey });
        return property.token;
    };
    const getBucket = (bucket) => {
        const result = bucket ?? _bucket;
        if (!result)
            throw new Error("bucket is not defined");
        return result;
    };
    const s = (0, semaphore_1.semaphore)(parallels);
    return {
        info: async (params) => {
            await s.acquire();
            return (0, exports.info)({
                ...params,
                token: await getToken(),
                bucket: getBucket(params.bucket),
            }).finally(() => s.release());
        },
        download: async (params) => {
            await s.acquire();
            return (0, exports.download)({
                ...params,
                token: await getToken(),
                bucket: getBucket(params.bucket),
            }).finally(() => s.release());
        },
        upload: async (params) => {
            await s.acquire();
            return (0, exports.upload)({
                ...params,
                token: await getToken(),
                bucket: getBucket(params.bucket),
            }).finally(() => s.release());
        },
        del: async (params) => {
            await s.acquire();
            return (0, exports.del)({
                ...params,
                token: await getToken(),
                bucket: getBucket(params.bucket),
            }).finally(() => s.release());
        },
        list: async (params) => {
            await s.acquire();
            return (0, exports.list)({
                ...params,
                token: await getToken(),
                bucket: getBucket(params.bucket),
            }).finally(() => s.release());
        },
        infoBucket: async (params) => {
            await s.acquire();
            return (0, exports.infoBucket)({
                ...params,
                token: await getToken(),
                bucket: getBucket(params.bucket),
            }).finally(() => s.release());
        },
        updateBucket: async (params) => {
            await s.acquire();
            return (0, exports.updateBucket)({
                ...params,
                token: await getToken(),
                bucket: getBucket(params.bucket),
            }).finally(() => s.release());
        },
    };
};
exports.getStorage = getStorage;
