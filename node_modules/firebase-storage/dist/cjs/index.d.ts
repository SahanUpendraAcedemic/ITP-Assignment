export interface BucketObject {
    kind: string;
    selfLink: string;
    id: string;
    name: string;
    projectNumber: string;
    metageneration: string;
    location: string;
    storageClass: string;
    etag: string;
    defaultEventBasedHold: boolean;
    timeCreated: string;
    updated: string;
    encryption: {
        defaultKmsKeyName: string;
    };
    acl: unknown[];
    defaultObjectAcl: unknown[];
    website: {
        mainPageSuffix: string;
        notFoundPage: string;
    };
    owner: {
        entity: string;
        entityId: string;
    };
    logging: {
        logBucket: string;
        logObjectPrefix: string;
    };
    cors: {
        origin?: string[];
        method?: string[];
        responseHeader?: string[];
        maxAgeSeconds?: number;
    }[];
    versioning: {
        enabled: boolean;
    };
    lifecycle: {
        rule: {
            action: {
                storageClass: string;
                type: string;
            };
            condition: {
                age: number;
                createdBefore: string;
                isLive: boolean;
                numNewerVersions: number;
                matchesStorageClass: string[];
                daysSinceCustomTime: number;
                customTimeBefore: string;
                daysSinceNoncurrentTime: number;
                noncurrentTimeBefore: string;
                matchesPrefix: string[];
                matchesSuffix: string[];
            };
        }[];
    };
    autoclass: {
        enabled: boolean;
        toggleTime: string;
        terminalStorageClass: string;
        terminalStorageClassUpdateTime: string;
    };
    labels: {
        [key: string]: string;
    };
    retentionPolicy: {
        retentionPeriod: string;
        effectiveTime: string;
        isLocked: boolean;
    };
    objectRetention: {
        mode: string;
    };
    billing: {
        requesterPays: boolean;
    };
    iamConfiguration: {
        publicAccessPrevention: string;
        uniformBucketLevelAccess: {
            enabled: boolean;
            lockedTime: string;
        };
    };
    locationType: string;
    customPlacementConfig: {
        dataLocations: string[];
    };
    softDeletePolicy: {
        retentionDurationSeconds: string;
        effectiveTime: string;
    };
    rpo: string;
}
export interface StorageObject {
    kind: string;
    id: string;
    selfLink: string;
    mediaLink: string;
    name: string;
    bucket: string;
    generation: string;
    metageneration: string;
    contentType: string;
    storageClass: string;
    size: string;
    md5Hash: string;
    cacheControl: string;
    crc32c: string;
    etag: string;
    timeCreated: string;
    updated: string;
    timeStorageClassUpdated: string;
}
export declare const createToken: ({ clientEmail, privateKey, }: {
    clientEmail: string;
    privateKey: string;
}) => Promise<string>;
export declare const info: ({ token, bucket, name, }: {
    token: string;
    bucket: string;
    name: string;
}) => Promise<StorageObject>;
export declare const download: ({ token, bucket, name, }: {
    token: string;
    bucket: string;
    name: string;
}) => Promise<ArrayBuffer>;
export declare const upload: ({ token, bucket, name, file, published, metadata, }: {
    token: string;
    bucket: string;
    name: string;
    file: Blob;
    published?: boolean | undefined;
    metadata?: {
        [key: string]: unknown;
    } | undefined;
}) => Promise<any>;
export declare const del: ({ token, bucket, name, }: {
    token: string;
    bucket: string;
    name: string;
}) => Promise<boolean>;
export declare const list: ({ token, bucket, }: {
    token: string;
    bucket: string;
}) => Promise<StorageObject[]>;
export declare const infoBucket: ({ token, bucket, }: {
    token: string;
    bucket: string;
}) => Promise<BucketObject>;
type TreePartial<T> = {
    [P in keyof T]?: T[P] extends (infer U)[] ? TreePartial<U>[] : T[P] extends object ? TreePartial<T[P]> : T[P];
};
export declare const updateBucket: ({ token, bucket, body, }: {
    token: string;
    bucket: string;
    body: TreePartial<BucketObject>;
}) => Promise<BucketObject[]>;
type ParamType<T extends (...args: never[]) => unknown, P = Parameters<T>[0]> = Omit<P, "token" | "bucket"> & {
    bucket?: string;
};
export declare const getStorage: ({ clientEmail, privateKey, bucket: _bucket, parallels, }: {
    clientEmail: string;
    privateKey: string;
    bucket?: string | undefined;
    parallels?: number | undefined;
}) => {
    info: (params: ParamType<typeof info>) => Promise<StorageObject>;
    download: (params: ParamType<typeof download>) => Promise<ArrayBuffer>;
    upload: (params: ParamType<typeof upload>) => Promise<any>;
    del: (params: ParamType<typeof del>) => Promise<boolean>;
    list: (params: ParamType<typeof list>) => Promise<StorageObject[]>;
    infoBucket: (params: ParamType<typeof infoBucket>) => Promise<BucketObject>;
    updateBucket: (params: ParamType<typeof updateBucket>) => Promise<BucketObject[]>;
};
export {};
